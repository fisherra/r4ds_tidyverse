---
title: "Unpacking the Tidyverse - purrr"
author: "Fisher Ankney"
date: "September 24, 2018"
output: html_document
---

<br>

This is the final installments in my *Unpacking the Tidyverse* series. Each of the eight posts focus on one of the core packages in Hadley Wickham's tidyverse. Instructions given in each post are mainly derived from Hadley's textbook, [R for Data Science](http://r4ds.had.co.nz/) and CRAN package documentation. This installment of *Unpacking the Tidyverse* focuses on iteration. We'll learn what for loops are, and how they work. Then we'll learn how to perform these same operations with purrr functions. The previous installment focuses on the categorical data manipulation package, [forcats]({{ site.baseurl }}/r4ds-forcats).

To use purrr, we must first download the tidyverse. 

### Library
```{r, message=F}
library('tidyverse')
```

<br> 

### Iteration By Hand

Iteration allows you to conduct the same operation on multiple inputs without tediously copying-and-pasting code. Here's a simple example of a for-loop.

First we'll create a dataframe with 4 variables: a, b, c, and d. Each of these variables will contian 10 randomly generated numbers from the normal distribution using the function `rnorm`. 

```{r}
df <- tibble(
a = rnorm(10),
b = rnorm(10), 
c = rnorm(10),
d = rnorm(10)
)

df
```

<br>

Now let's try to compute the mean of each variable
```{r error=T}
mean(df)
```

<br> 

well that doesn't work. I guess we'll have to specify each variable. 
```{r}
mean(df$a)
mean(df$b)
mean(df$c)
mean(df$d)
```

<br> 

Imagine we have 100 variables that we want to calculate the mean of. That wouldn't be very fun. That's where for loops come in. 

<br.

### For Loops

Let's make a for loop, and use it to calculate the mean of each of these variables. 
```{r}
# Step 1 
output_vector <- vector("double", ncol(df))

# Step 2 
for (i in seq_along((df))) {

# Step 3 
  output_vector[[i]] <- mean(df[[i]])
}

output_vector
```

<br> 

We've succefully created a for loop to iterate through the variables! Each for loop is broken down into three steps. 

The first step, you must create an output vector to store your results. It's easy to create an empty vector of the correct size using the `vector()` function. In the first arguement of `vector()` you specify what kind of vector to create. This could be specified as any of the data structures i.e. integer, logical, character, etc. The second argumenet of `vector()` is the length of the vector. Clever use of `ncol()`, `nrow()`, or `length()` will give you the proper length for your output vector. 

The second step of a for loop is to define the sequence. Here we determine what to loop over using base R's `seq_along()` function. Create the variable `i` as a counter variable. 

The third and most complicated step of creating a for loop is in the body of the sequence. Here we describe to R exactly what we want to do as we loop through our defined dataframe. Sometimes we simply want to take the mean of each variable, and store that number into our output vector. Other times we may want to insert a series of if then statements, of generate graphics of the data we're looping over. The possibilities are endless. 

Let's take our iteration discussion to the third and final level. Purrr functions. 

<br> 

### Purrr Functions

In our quest to find the mean of each of the four variables in `df`, can use the most basic purrr function `map()`. 

```{r}
df %>% 
  map(mean)
```

<br> 

The function `map` takes two main arguements, a target to iterate over, and a function to apply during that iteration. `map` Returns a list of values, but if you don't want a generic list you can the varients of the `map` function. 

- `map_lgl()` returns a logical vector. 
- `map_int()` returns an integer vector. 
- `map_dbl()` returns a double vector. 
- `map_chr()` returns a character vector.

Here's what `map_dbl()` looks like when applied to our favorite iteration-situation. 

```{r}
df %>%
  map_dbl(mean)
```

<br> 

That's smooooth. 

So let's make it more complex! How about we create our own function and test out the `map_chr` function. I want to run through a dataframe of arbitrary size, and return the words "positve", "negative", or "zero", if the elements are as such.

First lets make the custom function!

```{r}
# name the function 'classify_chr' with input = 'input'
classify_chr <- function(input) {

# set a counter equal to 1 
i <- 1

# create a save vector of input length
save_vect <- vector("character", length(input))

# main while loop, while counter is less than or equal
# to input length, classify the elements and put that
# character classification into the save vector. 
# Then, add one to the counter to move on to the next 
# element. 
while (i <= length(input))
  {
    if (input[[i]] > 0) {
      save_vect[[i]] = "positive"
    }
    if (input[[i]] < 0) {
      save_vect[[i]] = "negative"
    }
    if (input[[i]] == 0) {
      save_vect[[i]] = "zero"
    }
  i <- i + 1
  }

# When the save vector is full of output, collapse the
# results and separate them by a space. Finally, print
# the resulting output vector.
output <- str_c(save_vect, collapse=" ")
print(output)
}
```

<br>

Alright. That function was relatively easy to create! Let's test it out. 
```{r}
classify_chr(-1)
classify_chr(0)
classify_chr(1)
```

<br> 

Single entries are working as expected. Let's give the custom function a concantenated list of numbers and see what it does. 

```{r}
a <- c(-1,0,1)

classify_chr(a)
```

<br> 

Looking good, how about we step it up to the final level of complexity! Running through a tibble that has lists of numbers as it's variables.

```{r error=T}
test_tib <- tibble(
  a = sample(-10:10,10, replace = T),
  b = sample(1:10,10, replace = T),
  c = 0
)

test_tib


classify(test_tib)
```

<br> 

An Error! Oh no! Wait, that's exactly why we went through all of this. Thats where purrr comes in! Let's give it a shot.

```{r}
test_tib %>%
  map_chr(classify_chr)
```

<br> 

Alright! Not the prettiest of outputs, but it does what it's designed to do. And it's a great illustration of when we need to use the map function. 


#### mapping over multiple arguements 
```
mu <- list(5, 10, -3)

mu %>%
  map(rnorm, n=5)
```

#### mapping over two vectors in parallel


```
mu  <- list(5,10,-3)
sigma <- list(1,5,10)

map2_dbl(mu, sigma, rnorm, n=5)

```


```
pmap{}

```